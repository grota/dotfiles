#!/bin/bash
# Pump volume for playing audio streams
# Requires: jq, fzf (for interactive mode)

set -euo pipefail

DEFAULT_VOLUME=100
MAX_ALLOWED=300

# Blacklist: application names to skip (regex patterns for jq's test())
BLACKLIST_PATTERN="speech-dispatcher"

# Source shared volume utilities
# shellcheck source=dot_local/grota/scripts/volume-utils.sh
source "${DOTFILESREPO}/dot_local/grota/scripts/volume-utils.sh"

# ============================================================================
# Help
# ============================================================================
show_help() {
    cat <<'EOF'
pump-volume.sh - Set volume for playing audio streams

USAGE:
    pump-volume.sh [OPTIONS] [VOLUME] [APP_QUERY]

SCENARIOS:
    pump-volume.sh
        Interactive mode: prompt for volume (default 170%), then select
        sink(s) with fzf (multi-select enabled).

    pump-volume.sh <volume>
        Set volume to <volume>%, then interactively select sink(s) with fzf.

    pump-volume.sh <volume> <app_query>
        Set volume to <volume>%, open fzf with <app_query> pre-filled
        for quick confirmation.

    pump-volume.sh --no-interactive
        Non-interactive: apply default volume (170%) to ALL playing sinks.

OPTIONS:
    -n, --no-interactive    Apply to all playing sinks without prompts
    -h, --help              Show this help message

EXAMPLES:
    pump-volume.sh                  # Interactive, ask everything
    pump-volume.sh 200              # 200% volume, select sinks with fzf
    pump-volume.sh 150 firefox      # 150% volume, fzf pre-filtered to "firefox"
    pump-volume.sh --no-interactive # 170% to all playing sinks

NOTES:
    - Volume range: 1-300%
    - Streams matching "speech-dispatcher" are always excluded
    - Multi-select in fzf: use TAB to select multiple sinks
EOF
}

# ============================================================================
# Utility functions
# ============================================================================

# Extract a specific property for a sink index from text output
# Usage: get_sink_property_from_text <index> <property_name>
# Example: get_sink_property_from_text 1234 "media.name"
get_sink_property_from_text() {
    local target_idx="$1"
    local prop_name="$2"
    pactl list sink-inputs 2>/dev/null | awk -v target="$target_idx" -v prop="$prop_name" '
    /^Sink Input #/ {
        gsub(/[^0-9]/, "", $0)
        current_idx = $0 + 0
        next
    }
    current_idx == target && $0 ~ "^\\t\\t" prop " = " {
        sub(/.*= "/, "", $0)
        sub(/"$/, "", $0)
        print $0
        exit
    }
    '
}

# Get all sink-inputs as normalized JSON (one object per line)
# Uses JSON output, patching any "(null)" fields from text output
get_all_sinks_json() {
    local json_output
    json_output=$(pactl --format=json list sink-inputs 2>/dev/null)

    # Parse JSON, normalize to {index, app, media, volume} objects
    echo "$json_output" | jq -c '
        .[]
        | select(.corked == false)
        | {
            index: .index,
            app: .properties."application.name",
            media: .properties."media.name",
            vol_left: .volume."front-left".value_percent,
            vol_right: .volume."front-right".value_percent
          }
    ' 2>/dev/null | while IFS= read -r line; do
        local idx app media vol_left vol_right

        idx=$(echo "$line" | jq -r '.index')
        app=$(echo "$line" | jq -r '.app')
        media=$(echo "$line" | jq -r '.media')
        vol_left=$(echo "$line" | jq -r '.vol_left // ""')
        vol_right=$(echo "$line" | jq -r '.vol_right // ""')

        # Patch null fields from text output
        if [[ "$app" == "(null)" ]]; then
            app=$(get_sink_property_from_text "$idx" "application.name")
        fi
        if [[ "$media" == "(null)" ]]; then
            media=$(get_sink_property_from_text "$idx" "media.name")
        fi

        jq -c -n --argjson idx "$idx" --arg app "$app" --arg media "$media" \
            --arg vol_left "$vol_left" --arg vol_right "$vol_right" \
            '{index: $idx, app: $app, media: $media, vol_left: $vol_left, vol_right: $vol_right}'
    done
}

# Get all playing sink-inputs as JSON (filtered by blacklist)
get_playing_sinks() {
    get_all_sinks_json | jq -c --arg blacklist "$BLACKLIST_PATTERN" '
        select(.app | test($blacklist) | not)
    ' 2>/dev/null
}

# Prompt user for volume with default
# Uses DEFAULT_VOLUME from environment (defaults to 100)
prompt_volume() {
    local default="${DEFAULT_VOLUME:-100}"
    local input
    read -rp "Volume % [${default}]: " input
    if [[ -z "$input" ]]; then
        echo "$default"
    else
        validate_volume "$input"
    fi
}

# Format sink for fzf display: "index<TAB>app, media (vol_left/vol_right)"
format_sink_for_fzf() {
    local json="$1"
    local index app media vol_left vol_right
    index=$(echo "$json" | jq -r '.index')
    app=$(echo "$json" | jq -r '.app')
    media=$(echo "$json" | jq -r '.media // "(no media)"')
    vol_left=$(echo "$json" | jq -r '.vol_left // "?"')
    vol_right=$(echo "$json" | jq -r '.vol_right // "?"')
    printf '%s\t%s, %s (%s/%s)\n' "$index" "$app" "$media" "$vol_left" "$vol_right"
}

# Select sinks using fzf (multi-select)
# $1 = optional query to pre-fill fzf
select_sinks_fzf() {
    local query="${1:-}"
    local sinks_json
    sinks_json=$(get_playing_sinks)

    if [[ -z "$sinks_json" ]]; then
        echo "No audio streams currently playing." >&2
        exit 0
    fi

    # Build fzf input: one line per sink
    local fzf_input=""
    while read -r line; do
        fzf_input+="$(format_sink_for_fzf "$line")"$'\n'
    done <<< "$sinks_json"

    # Remove trailing newline
    fzf_input="${fzf_input%$'\n'}"

    # Run fzf with multi-select
    local fzf_args=(
        --multi
        --header="Select sink(s) - TAB to multi-select, ENTER to confirm"
        --delimiter=$'\t'
        --with-nth=2
        --preview-window=hidden
    )

    if [[ -n "$query" ]]; then
        fzf_args+=(--query="$query")
    fi

    local selected
    selected=$(echo "$fzf_input" | fzf "${fzf_args[@]}") || {
        echo "No sinks selected." >&2
        exit 0
    }

    # Return selected indices (first field)
    echo "$selected" | cut -f1
}

# Get sink info for a specific index
get_sink_info() {
    local idx="$1"
    get_all_sinks_json | jq -r --argjson idx "$idx" '
        select(.index == $idx) |
        "\(.app) | \(.media // "(no media)")"
    ' 2>/dev/null
}

# Apply volume to given sink indices
apply_volume() {
    local volume="$1"
    shift
    local indices=("$@")

    echo "Applied ${volume}% volume to:"
    for index in "${indices[@]}"; do
        # Get sink info for display
        local info
        info=$(get_sink_info "$index")

        echo "  Sink Input #$index: $info"
        pactl set-sink-input-volume "$index" "${volume}%"
    done
}

# Apply volume to all playing sinks (non-interactive)
apply_to_all() {
    local volume="$1"
    local sinks_json
    sinks_json=$(get_playing_sinks)

    if [[ -z "$sinks_json" ]]; then
        echo "No audio streams currently playing."
        exit 0
    fi

    echo "Applied ${volume}% volume to all playing apps:"

    while read -r line; do
        local index app media
        index=$(echo "$line" | jq -r '.index')
        app=$(echo "$line" | jq -r '.app')
        media=$(echo "$line" | jq -r '.media // "(no media)"')

        echo "  Sink Input #$index: $app | $media"
        pactl set-sink-input-volume "$index" "${volume}%"
    done <<< "$sinks_json"
}

# ============================================================================
# Main
# ============================================================================

main() {
    local interactive=true
    local volume=""
    local app_query=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -n|--no-interactive)
                interactive=false
                shift
                ;;
            *)
                # First positional arg = volume, second = app_query
                if [[ -z "$volume" ]]; then
                    volume="$1"
                elif [[ -z "$app_query" ]]; then
                    app_query="$1"
                else
                    echo "Error: Too many arguments" >&2
                    show_help
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Scenario 4: --no-interactive
    if [[ "$interactive" == false ]]; then
        if [[ -n "$volume" ]]; then
            volume=$(validate_volume "$volume")
        else
            volume="$DEFAULT_VOLUME"
        fi
        apply_to_all "$volume"
        exit 0
    fi

    # Interactive scenarios

    # Scenario 1: No params - ask for sinks, then volume
    # Select sinks with fzf (optionally with pre-filled query)
    local selected_indices
    selected_indices=$(select_sinks_fzf "$app_query")

    if [[ -z "$volume" ]]; then
        volume=$(prompt_volume)
    else
        # Scenario 2 & 3: Volume provided
        volume=$(validate_volume "$volume")
    fi

    # Convert newline-separated indices to array
    local indices_array=()
    while read -r idx; do
        [[ -n "$idx" ]] && indices_array+=("$idx")
    done <<< "$selected_indices"

    if [[ ${#indices_array[@]} -eq 0 ]]; then
        echo "No sinks selected."
        exit 0
    fi

    apply_volume "$volume" "${indices_array[@]}"
}

main "$@"
